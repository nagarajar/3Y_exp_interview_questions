Project Details and my achivements
=========================================
REMS - Renewable Energy Management System:
REMS enables proactive and efficient management of renewable assets by providing greater insight into operations and analyzing key performance indicators and their evolution. The solution facilitates timely, strategic decision-making, which leads to greater efficiency, reduced downtime and optimized performance.
REMS comprises an integrated set of tools to maximize energy production, increase availability, control energy losses and improve overall operational performance that has a direct impact on business revenues. 
=========================================
Technical:
1. Spring Boot: 3.1.4
2. Spring Cloud: 2022.0.4
3. Database: MongoDB
4. Lombok
5. DevTools
6. Spring Boot Validation
7. Actuator
8. Spring Web
9. Webflux
10. Eureka Client

Microservices:
1. common-api : Plant Group(me), Plant, Location, Device Type, Device
Description: This api(ms)/module contains the commonly used functionalities throught our application. For example consider a solar plant -> a plant will comes under one plant group, the plant will have the location  and the plant will have multiple devices, the devices are grouped based on diffent device types.

Achivements: I worked on Plant Group fuctionality end to end, written test cases(Junit&Mockito) for all layers both positive and negative senario's.

2. oandm-api : Work Order, WO Function(me), WO Action, WO Service Engineer, Spare Cost, WO Image, WO Observation, WO Problem, WO History(me), WO Schedule, WO Skills, WO Status, WO Type.
Description: oandm - Operation and Maintainance this api(ms)/module contains functionality related to work orders, work orders are nothing but a scheduled works for regular intervels(daily, weekly, monthly) and some of them are emergency works that will have priority(High, Mediun, Low).
These work orders will help managers and teams to monitor, operate the plant easily.

Achivements: I worked on WO Function & WO History fuctionality end to end, written test cases(Junit&Mockito) for all layers both positive and negative senario's.


3. discovery-server: Eureka Server Dependency, Spring Web
Description: Eureka Server is an application that holds the information about all client-service applications. Every Micro service will register into the Eureka server and Eureka server knows all the client applications running on each port and IP address. Eureka Server is also known as Discovery Server.

4. api-gateway: Spring Security, Oauth2-resource-server, eureka-client, spring-cloud-gateway
Description: Spring Cloud Gateway provides a library for making API gateways on top of Spring and Java. It provides a flexible way of routing requests based on a number of criteria, as well as focuses on cross-cutting problems like security, resiliency, and monitoring. 
The main purpose of integrating the API gateway in microservice communication is, API Gateway acts as a single entry point to access services.

common-api, oandm-api, discovery-server and rems-web routes are configured under api-gateway.
Included security using spring security with oauth2-resource-server with allows all paths from eureka-client.

5. rems-web: Thymeleaf, eureka-client, Oauth2-client, keycloak-admin-client

3rd party api's - weather data
1. solar-anywhere-client: Webflux, Web
Used: WebClient, Scheduling
Description: solar-anywhere is a third party api which will provide the data related to solar and weather. Refer the below links to know more about it.
a. https://www.solaranywhere.com/
b. https://developers.cleanpower.com/irradiance-and-weather-data/complete-schema/createweatherdatarequest/
c. https://www.solaranywhere.com/support/data-fields/definitions/
d. https://www.solaranywhere.com/support/data-fields/resolution/
e. https://www.solaranywhere.com/support/geographic-coverage/
f. https://www.solaranywhere.com/products/solaranywhere-forecast/

Achivements: I written solar-anywhere-client to get the data from the solar-anywhere api based on the given lat and long with required parameters.
I used the web client to make http calls and to get data periodically used the scheduling also to handle/process multiple locations data parallely used multithreading.

@Slf4j
@Configuration
@EnableScheduling
@EnableAsync
@SpringBootApplication
public class SolarAnywhereAPIClient {

  public static void main(String[] args) {
    log.debug(
        "SolarAnywhereAPIClient Application Stated: " + AppUtil.DTF.format(LocalDateTime.now()));
    SpringApplication.run(SolarAnywhereAPIClient.class, args);
  }

  @Bean("threadPoolTaskExecutor")
  TaskExecutor getAsyncExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(10);
    executor.setMaxPoolSize(25);
    executor.setWaitForTasksToCompleteOnShutdown(true);
    executor.setThreadNamePrefix("SA-API-Async-");
    return executor;
  }

}

@Configuration
public class WebClientConfig {

  @Value("${RESPONSE_URL}")
  private String responseUrl;

  private ClientHttpConnector connector() {
    return new ReactorClientHttpConnector(HttpClient.create(ConnectionProvider.newConnection()));
  }

  @Bean
  WebClient webClient() {
    int memoryLimit = 1000;
    ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
        .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024 * memoryLimit))
        .build();

    return WebClient.builder().clientConnector(connector()).exchangeStrategies(exchangeStrategies)
        .baseUrl(responseUrl).build();

  }

}

@Component
public class ForeCastWeatherDataResultResponseListener
    extends AbstractMongoEventListener<ForeCastWeatherDataResultResponse> {
  public static final String SEQUENCE_NAME = "forecast_weatherdata_result_response_sequence";

  @Autowired
  PrimaryKeyGeneratorService pkGeneratorService;

  @Override
  public void onBeforeConvert(BeforeConvertEvent<ForeCastWeatherDataResultResponse> event) {
    if (event.getSource().getWeatherDataResultResponseId() == null) {
      event.getSource().setWeatherDataResultResponseId(pkGeneratorService.generateSequence(
          ForeCastWeatherDataResultResponseListener.SEQUENCE_NAME));
    }
  }

}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "primary_sequences")
public class PrimarySequence {
  @Id
  private String id;
  private Long sequence;
}

@Service
public class PrimaryKeyGeneratorService {

  @Autowired
  MongoOperations mongoOperations;

  public long generateSequence(String sequenceName) {
    PrimarySequence counter = mongoOperations.findAndModify(query(where("_id").is(sequenceName)),
        new Update().inc("sequence", 1), options().returnNew(true).upsert(true),
        PrimarySequence.class);
    return !Objects.isNull(counter) ? counter.getSequence() : 1;
  }

}

@Service
@Slf4j
public class RequestService implements IRequestService {

  @Autowired
  private WebClient webClient;

  @Value("${REQUEST_URL}")
  private String requestUrl;

  @Override
  public CreateWeatherDataResponse createWeatherDataRequest(
      CreateWeatherDataRequest createWeatherDataRequest, String apiKey) {
    CreateWeatherDataResponse createWeatherDataResponse = null;
    try {
      log.info("--> Enter into WeatherDataApiServiceImpl::createWeatherDataRequest");

      createWeatherDataResponse = webClient.post().uri(requestUrl)
          .header("Content-Type", "application/json").header("X-Api-Key", apiKey)
          .bodyValue(createWeatherDataRequest).accept(MediaType.APPLICATION_JSON).retrieve()
          .bodyToMono(CreateWeatherDataResponse.class)
          .onErrorResume(WebClientResponseException.class, ex -> {
            log.error(ex.getMessage());
            log.error(ex.getResponseBodyAsString());
            return Mono.error(ex);
          }).block();

      log.info("CreateWeatherDataResponse: {}", createWeatherDataResponse);

      log.info("<-- Exit from WeatherDataApiServiceImpl::createWeatherDataRequest");
    } catch (Exception e) {
      log.error("Error Occured in createWeatherDataRequest");
      log.error(e.getMessage());
      throw new SolarAnyWhereBusinessException(e.getMessage());
    }

    return createWeatherDataResponse;
  }

  @Override
  public CreateWeatherDataResponse hrCreateWeatherDataRequest(
      HRCreateWeatherDataRequest hrCreateWeatherDataRequest, String apiKey) {
    CreateWeatherDataResponse createWeatherDataResponse = null;
    try {
      log.info("--> Enter into WeatherDataApiServiceImpl::hrCreateWeatherDataRequest()");

      createWeatherDataResponse =
          webClient.post().uri(requestUrl).header("Content-Type", "application/json")
              .header("X-Api-Key", apiKey).bodyValue(hrCreateWeatherDataRequest)
              .accept(MediaType.APPLICATION_JSON).retrieve()
              .bodyToMono(CreateWeatherDataResponse.class)
              .onErrorResume(WebClientResponseException.class, ex -> {
                log.error(ex.getMessage());
                log.error(ex.getResponseBodyAsString());
                return Mono.error(ex);
              }).block();

      log.info("CreateWeatherDataResponse: {}", createWeatherDataResponse);

      log.info("<-- Exit from WeatherDataApiServiceImpl::hrCreateWeatherDataRequest()");

    } catch (Exception e) {
      log.error("Error Occured in hrCreateWeatherDataRequest");
      log.error(e.getMessage());
      throw new SolarAnyWhereBusinessException(e.getMessage());
    }

    return createWeatherDataResponse;
  }

}

@Service
@Slf4j
public class ResponseService implements IResponseService {

  @Autowired
  WeatherLocationRepository locationRepository;
  @Autowired
  private WebClient webClient;
  @Value("${RESPONSE_URL}")
  private String responseUrl;

  @Override
  public GetWeatherDataResultResponse getWeatherDataResultResponse(String weatherRequestId,
                                                                   WeatherLocationResponse location)
      throws Exception {
    log.info("--> Enter into WeatherDataApiServiceImpl::getWeatherDataResultResponse()");

    GetWeatherDataResultResponse getWeatherDataResultResponse = null;
    do {
      Thread.sleep(5000); // wait for 5 seconds before checking the status again
      getWeatherDataResultResponse = webClient.get().uri(responseUrl, weatherRequestId)
          .header("X-Api-Key", location.apiKey())
          .accept(MediaType.APPLICATION_JSON)
          .retrieve().bodyToMono(GetWeatherDataResultResponse.class)
          .onErrorResume(WebClientResponseException.class, ex -> {
            log.error(ex.getMessage());
            log.error(ex.getResponseBodyAsString());
            return Mono.error(ex);
          }).block();
    } while (getWeatherDataResultResponse != null &&
        "Pending".equals(getWeatherDataResultResponse.Status()));

    log.info("<-- Exit from WeatherDataApiServiceImpl::getWeatherDataResultResponse()");

    return getWeatherDataResultResponse;
  }


}

@Service
@Slf4j
public class WeatherDataApiServiceImpl implements IWeatherDataAPIService {
 @Override
  public String foreCastWeatherDataRequestProcess() {
    try {
      log.info("--> Enter into WeatherDataApiServiceImpl::foreCastWeatherDataRequestProcess()");

      // 1. Get all active locations
      List<WeatherLocationResponse> activeWeatherLocations = getAllActiveWeatherLocations();

      // 2. Process each location in parallel
      activeWeatherLocations.forEach(location -> executor.execute(() -> {
          try {
            // 3. Process each location sequentially
            processForeCastWeatherLocation(location);
          } catch (Exception e) {
            log.error(
                "Error occured while processing foreCastWeatherDataRequestProcess() with location: " +
                    location.name() + ": " + e.getMessage());
            throw new SolarAnyWhereBusinessException(e.getMessage());
          }
        }));

      log.info("<-- Exit from WeatherDataApiServiceImpl::foreCastWeatherDataRequestProcess()");
      return "Fore Cast WeatherDataRequestProcess Successfully Completed";
    } catch (Exception e) {
      throw new SolarAnyWhereBusinessException(e.getMessage());
    }
  }
}

@Slf4j
@Service
public class WeatherDataService implements IWeatherDataService {

  @Autowired
  private IWeatherDataAPIService weatherDataAPIService;

  @Async("threadPoolTaskExecutor")
  @Override
  public CompletableFuture<Boolean> processForeCastAPIRequest() {
    log.info("--> Enter into WeatherDataService::processForeCastAPIRequest()");
    log.info("<-- Exit from WeatherDataService::processForeCastAPIRequest()");
    return CompletableFuture.supplyAsync(() -> {
      try {
        String result = weatherDataAPIService.foreCastWeatherDataRequestProcess();
        log.info("WeatherDataService::foreCastWeatherDataRequestProcess() result - {}", result);
        return true;
      } catch (Exception e) {
        log.error("Error occured while processing foreCastWeatherDataRequestProcess()", e);
        return false;
      }
    });
  }
}


2. visual-crossing-client3: Webflux, Web
Used: WebClient, Scheduling
Description: visual-crossing is a third party api which will provide the data related to solar and weather. Refer the below links to know more about it.
a. https://www.visualcrossing.com/
b. https://www.visualcrossing.com/resources/documentation/weather-api/timeline-weather-api/
c. https://www.visualcrossing.com/resources/documentation/weather-api/weather-api-documentation/
d. https://www.visualcrossing.com/resources/documentation/weather-api/energy-elements-in-the-timeline-weather-api/
e. https://www.visualcrossing.com/resources/documentation/weather-api/unit-groups-and-measurement-units/
f. https://www.visualcrossing.com/resources/documentation/weather-data/how-to-obtain-solar-radiation-data/
g. https://www.visualcrossing.com/resources/documentation/weather-api/date-and-times-in-the-weather-api/
h. https://www.visualcrossing.com/resources/documentation/weather-api/defining-icon-set-in-the-weather-api/

Achivements: I written solar-anywhere-client to get the data from the solar-anywhere api based on the given lat and long with required parameters.
I used the web client to make http calls and to get data periodically used the scheduling also to handle/process multiple locations data parallely used multithreading.

@Service
@Slf4j
public class VCRequestService implements IVCRequestService {

	@Autowired
	private WebClient webClient;
	
	static final String ELEMENTS = "datetime,ghiradiation,dniradiation,difradiation,gtiradiation,sunazimuth,sunelevation,windspeed50,winddir50,windspeed80,winddir80,windspeed100,winddir100";
	
	static final String INCLUDE = "days";
	

	@Override
	public VisualCrossingResponse createVCRequestToGetSpecificDateRangeDaysData(String nameOrLatLong, LocalDateTime startDate,
			LocalDateTime endDate, String apiKey) {
		VisualCrossingResponse visualCrossingResponse = null;
		try {
			log.info("--> Enter into VCRequestService::createVCRequestToGetSpecificDateRangeDaysData");

			visualCrossingResponse = webClient.get()
					.uri(uriBuilder -> uriBuilder.path("/{nameOrLatLong}/{startDate}/{endDate}")
							.queryParam("key", apiKey).queryParam("include", INCLUDE)
							.build(nameOrLatLong, startDate, endDate))
					.accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(VisualCrossingResponse.class)
					.onErrorResume(WebClientResponseException.class, ex -> {
						log.error(ex.getMessage());
						log.error(ex.getResponseBodyAsString());
						return Mono.error(ex);
					}).block();

			//log.info("VisualCrossingResponse: {}", visualCrossingResponse);

			log.info("<-- Exit from VCRequestService::createVCRequestToGetSpecificDateRangeDaysData");
		} catch (Exception e) {
			log.error("Error Occurred in VCRequestService::createVCRequestToGetSpecificDateRangeDaysData");
			log.error(e.getMessage());
			throw new VisualCrossingBusinessException(e.getMessage());
		}

		return visualCrossingResponse;
	}

	@Override
	public VisualCrossingResponse createVCRequestToGetSpecificDateRangeDayWithHoursData(String nameOrLatLong,
			LocalDateTime startDate, LocalDateTime endDate, String apiKey) {
		VisualCrossingResponse visualCrossingResponse = null;
		try {
			log.info("--> Enter into VCRequestService::createVCRequestToGetSpecificDateRangeDayWithHoursData");

			visualCrossingResponse = webClient.get()
					.uri(uriBuilder -> uriBuilder.path("/{nameOrLatLong}/{startDate}/{endDate}")
							.queryParam("key", apiKey).build(nameOrLatLong, startDate, endDate))
					.accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(VisualCrossingResponse.class)
					.onErrorResume(WebClientResponseException.class, ex -> {
						log.error(ex.getMessage());
						log.error(ex.getResponseBodyAsString());
						return Mono.error(ex);
					}).block();

			//log.info("VisualCrossingResponse: {}", visualCrossingResponse);

			log.info("<-- Exit from VCRequestService::createVCRequestToGetSpecificDateRangeDayWithHoursData");
		} catch (Exception e) {
			log.error("Error Occurred in VCRequestService::createVCRequestToGetSpecificDateRangeDayWithHoursData");
			log.error(e.getMessage());
			throw new VisualCrossingBusinessException(e.getMessage());
		}

		return visualCrossingResponse;
	}

	@Override
	public VisualCrossingExtendedElementsResponse createVCRequestToGetSpecificDateRangeExtendedElementsDaysData(String nameOrLatLong,
			LocalDateTime startDate, LocalDateTime endDate, String apiKey, double solarTiltAngle) {
		VisualCrossingExtendedElementsResponse visualCrossingExtendedElementsResponse = null;
		try {
			log.info("--> Enter into VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDaysData");
			
			visualCrossingExtendedElementsResponse = webClient.get()
					.uri(uriBuilder -> uriBuilder.path("/{nameOrLatLong}/{startDate}/{endDate}")
							.queryParam("key", apiKey).queryParam("include", INCLUDE)
							.queryParam("elements", ELEMENTS).queryParam("solarTiltAngle", solarTiltAngle)
							.build(nameOrLatLong, startDate, endDate))
					.accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(VisualCrossingExtendedElementsResponse.class)
					.onErrorResume(WebClientResponseException.class, ex -> {
						log.error(ex.getMessage());
						log.error(ex.getResponseBodyAsString());
						return Mono.error(ex);
					}).block();

			//log.info("VisualCrossingExtendedElementsResponse: {}", visualCrossingExtendedElementsResponse);

			log.info("<-- Exit from VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDaysData");
		} catch (Exception e) {
			log.error("Error Occurred in VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDaysData");
			log.error(e.getMessage());
			throw new VisualCrossingBusinessException(e.getMessage());
		}

		return visualCrossingExtendedElementsResponse;
	}

	@Override
	public VisualCrossingExtendedElementsResponse createVCRequestToGetSpecificDateRangeExtendedElementsDayWithHoursData(
			String nameOrLatLong, LocalDateTime startDate, LocalDateTime endDate, String apiKey, double solarTiltAngle) {
		VisualCrossingExtendedElementsResponse visualCrossingExtendedElementsResponse = null;
		try {
			log.info("--> Enter into VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDayWithHoursData");

			visualCrossingExtendedElementsResponse = webClient.get()
					.uri(uriBuilder -> uriBuilder.path("/{nameOrLatLong}/{startDate}/{endDate}")
							.queryParam("key", apiKey).queryParam("elements", ELEMENTS).queryParam("solarTiltAngle", solarTiltAngle)
							.build(nameOrLatLong, startDate, endDate))
					.accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(VisualCrossingExtendedElementsResponse.class)
					.onErrorResume(WebClientResponseException.class, ex -> {
						log.error(ex.getMessage());
						log.error(ex.getResponseBodyAsString());
						return Mono.error(ex);
					}).block();

			//log.info("VisualCrossingExtendedElementsResponse: {}", visualCrossingExtendedElementsResponse);

			log.info("<-- Exit from VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDayWithHoursData");
		} catch (Exception e) {
			log.error("Error Occurred in VCRequestService::createVCRequestToGetSpecificDateRangeExtendedElementsDayWithHoursData");
			log.error(e.getMessage());
			throw new VisualCrossingBusinessException(e.getMessage());
		}

		return visualCrossingExtendedElementsResponse;
	}

}




Vender api's
1. solar-edge-client: spring-kafka, web
Description: SolarEdge Technologies provides cloud-based monitoring and control services for its clients. The company offers a cloud-based platform called "SolarEdge Monitoring" that allows users to remotely monitor and manage their solar PV systems in real-time.

https://knowledge-center.solaredge.com/sites/kc/files/se_monitoring_api.pdf

We can pull the site details periodically from the solar edge api.

2. also-energy-client: spring-kafka, web
Description: Also Energy provides cloud-based services to its clients for monitoring and managing energy systems. Their cloud-based platform allows users to remotely access and monitor the performance of their energy assets, which can include solar PV systems, wind turbines, and other renewable energy installations. This cloud-based service offers real-time data, analytics, reporting, and other features to help clients optimize the efficiency and performance of their energy systems. Users can access this platform through web portals and mobile apps, making it convenient for remote monitoring and management of their energy assets.

We can pull the site details periodically from the also energy api.


kafka
1. data-logger: 
Description: data-logger is an api which will take the data from solar-edge-client and send them in que using kafka message brocker so we wont loss the data incase of client api stops in between.

